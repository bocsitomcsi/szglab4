package Tower;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

import Tower.Cell.CellType;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : Enemy.java
//  @ Date : 2014.03.20.
//  @ Author : 
//
//




/**
 * Az ellensegek absztrakt ososztalya.
 */
public abstract class Enemy
{
	/**
	 * Eletero.
	 */
	protected int healthPoint;
	/**
	 * Az ellenseg ennyi idonkent tud lepni.
	 */
	protected int actualSpeed;
	/**
	 * Az ellenseg lassitas nelkul ennyi idonkent tud lepni.
	 */
	protected int originalSpeed;
	/**
	 * Az ellenseg halalakor szarumanhoz kerulo varazsero.
	 */
	protected int magic;
	/**
	 * Az ellenseg eletben van-e.
	 */
	protected boolean isDead;
	/**
	 * Az az idopont amikor az ellenseg legutoljara lepett.
	 */
	protected long lastTime;
	/**
	 * Az ellenseg pozicioja.
	 */
	protected Cell position;
	/**
	 * Az egyes ellenseg tipusok sebessegei.
	 */
	public static HashMap<String, Integer> enemySpeeds = 
			new HashMap<String,Integer>();
	/**
	 * Statikus inicializalo blokk az egyes ellenseg tipusok
	 * alapertelmezett sebessegeinek beallitasara
	 */
	static {
		enemySpeeds.put("dwarf", 2000);
		enemySpeeds.put("elf", 500);
		enemySpeeds.put("hobbit", 700);
		enemySpeeds.put("human", 1000);
	}

	/**
	 * Konstruktor.
	 * @param hp  eletero.
	 * @param as  Az aktualis sebesseg.
	 * @param os  Az eredeti, lassitas nelkuli sebesseg.
	 * @param m  Az ellenseg halalakor szarumanhoz kerulo varazsero.
	 */
	public Enemy(int hp, int as, int os, int m)
	{
		this.healthPoint = hp;
		this.actualSpeed = as;
		this.originalSpeed = os;
		this.magic = m;
		this.isDead = false;
		this.lastTime = System.currentTimeMillis();
		this.enemySpeeds = new HashMap<String,Integer>();
		System.out.println("Elf created");
	}

	/**
	 * Visszaad egy masolatot az objektumrol. Csak shallow copy tortenik.
	 * @return  A klon objektum.
	 */
	public abstract Enemy clone();
	
	/**
	 * Getter a healthPoint attributumra.
	 * @return  A healthPoint attributum.
	 */
	public int getHealthPoint()
	{
		return this.healthPoint;
	}

	/**
	 * Getter az actualSpeed attributumra.
	 * @return  Az actualSpeed attributum.
	 */
	public int getActualSpeed()
	{
		return this.actualSpeed;
	}

	/**
	 * Getter az originalSpeed attributumra.
	 * @return  Az originalSpeed attributum.
	 */
	public int getOriginalSpeed()
	{
		String logString = "Enemy.getOriginalSpeed()";
		Logger.Log(1, logString, this);

		Logger.Log(0, logString, this);

		return this.originalSpeed;
	}

	/**
	 * Getter a magic attributumra.
	 * @return  A magic attributum.
	 */
	public int getMagic()
	{
		return this.magic;
	}

	/**
	 * Getter a lastTime attributumra.
	 * @return  A lastTime attributum.
	 */
	public long getLastTime()
	{
		return this.lastTime;
	}

	/**
	 * Getter az isDead attributumra.
	 * @return  Az isDead attributum.
	 */
	public boolean getIsDead()
	{
		return this.isDead;
	}

	/**
	 * Getter a position attributumra.
	 * @return  A position attributum.
	 */
	public Cell getPosition()
	{
		String logString = "Enemy.getPosition()";
		Logger.Log(1, logString, this);

		Logger.Log(0, logString, this);

		return this.position;
	}

	/**
	 * Setter a healthPoint attributumra.
	 * @param hp  A healthPoint attributum kivant erteke.
	 */
	public void setHealthPoint(int hp)
	{
		this.healthPoint = hp;
	}

	/**
	 * Setter az actualSpeed attributumra.
	 * @param as  Az actualSpeed attributum kivant erteke.
	 */
	public void setActualSpeed(int as)
	{
		this.actualSpeed = as;

	}

	/**
	 * Setter az originalSpeed attributumra.
	 * @param os  Az originalSpeed attributum kivant erteke.
	 */
	public void setOriginalSpeed(int os)
	{
		this.originalSpeed = os;
	}

	/**
	 * Setter a magic attributumra.
	 * @param m  A magic attributum kivant erteke.
	 */
	public void setMagic(int m)
	{
		this.magic = m;
	}

	/**
	 * Setter a lastTime attributumra.
	 * @param lt  A lastTime attributum kivant erteke.
	 */
	public void setLastTime(long lt)
	{
		this.lastTime = lt;
	}

	/**
	 * Setter az isDead attributumra.
	 * @param dead  Az isDead attributum kivant erteke.
	 */
	public void setIsDead(boolean dead)
	{
		this.isDead = dead;
	}

	/**
	 * Setter a position attributumra.
	 * @param pos  A position attributum kivant erteke.
	 */
	public void setPosition(Cell pos)
	{
		String logString = "Enemy.setPosition(position)";
		Logger.Log(1, logString, this);

		this.position = pos;

		Logger.Log(0, logString, this);
	}

	/**
	 * Atlepteti az ellenseget egy olyan veletlenszeruen kivalasztott
	 *  szomszedos cellara, amelyik ut vagy vegpont es a hozza tartozo
	 *  boolean ertek igaz.
	 * Az uj cellatol elkeri a rajta talalhato akadalyt es ha kell
	 *  akkor lassitja az ellenseget, vagy visszaallitja a sebesseget az
	 *  eredetire.
	 * @return Az uj cellatol elkert akadaly objektum. 
	 *  Ha nincs akadaly az uj cellan, akkor null-t ad vissza.
	 */
	protected Obstacle moveToNextCell() {
		ArrayList<Cell> nextCells = new ArrayList<Cell>();
		// Vegigiteralunk a szomszedos cellakon
		for(Entry<Cell, Boolean> neighbour : position.getNeighbours().values()) {
			Cell cell = neighbour.getKey();
			boolean bool = neighbour.getValue();
			// Csak azokat mentjuk el a listankba, amelyek ut vagy vegpont tipusuak
			// es igaz a hozzajuk tartozo bool valtozo
			if ((cell.getCellType() == CellType.Road || cell.getCellType() == CellType.EndPoint)
					&& bool) {
				nextCells.add(cell);
			}
		}

		// Csak akkor lepunk, ha van jo szomszedos cella
		if (!nextCells.isEmpty()) {
			// A szomszedos cellak kozul kivalasztunk egy veletlen elemet
			// es beallitjuk a pozicionkat
			int random = (int)(Math.random() * nextCells.size());
			position = nextCells.get(random);

			// Visszallitjuk a sebesseget az eredetire ha kell
			if (actualSpeed != originalSpeed) {
				actualSpeed = originalSpeed;
			}
		}

		// Elkerjuk az uj cellan levo akadalyt, es ha van akadaly akkor lassitunk
		Obstacle obstacle = position.getObstacle();
		if (obstacle != null) {
			actualSpeed *= obstacle.getSlowRate();
		}

		return obstacle;
	}

	/**
	 * Az ellenseg eleterejet a parameterkent kapott power-rel,
	 *  es a bonus kollekcioban tarolt az ellenseg konkret tipusahoz
	 *  tartozo ertekkel csokkenti.
	 * Ha az elet 0 ala csokken, akkor beallitja az isDead valtozo erteket true-ra.
	 * @param power  A sebzes erteke.
	 * @param bonus  Az egyes ellenseg tipusokhoz tartozo bonusz sebzesek.
	 * @return Az ellenseg belehalt-e a sebzesbe.
	 */
	public abstract boolean damage(int power, HashMap<String, Integer> bonus);

	/**
	 * Ertesiti az ellenfelet az ido mulasarol.
	 */
	public void tick()
	{
		long current = System.currentTimeMillis();
		// Ha eltelt a legutobbi mozgas ota a megfelelo ido akkor mozgatunk.
		if (current - lastTime >= actualSpeed) {
			move();
			lastTime = current;
		}
	}

	/**
	 * Az ellenseget mozgatja. 
	 * Ezen a szinten egy tisztan virtualis fuggveny.
	 */
	public abstract void move();
}
